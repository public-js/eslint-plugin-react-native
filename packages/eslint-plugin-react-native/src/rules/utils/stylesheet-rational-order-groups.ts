/* 1. Positioning */
const positioning: string[] = ['position', 'top', 'right', 'bottom', 'left', 'zIndex'];

/* Border */
const borderProps: string[] = [
    'border',
    'borderColor',
    'borderStyle',
    'borderWidth',
    'borderTop',
    'borderTopColor',
    'borderTopWidth',
    'borderTopStyle',
    'borderRight',
    'borderRightColor',
    'borderRightWidth',
    'borderRightStyle',
    'borderBottom',
    'borderBottomColor',
    'borderBottomWidth',
    'borderBottomStyle',
    'borderLeft',
    'borderLeftColor',
    'borderLeftWidth',
    'borderLeftStyle',
    'borderRadius',
    'borderTopLeftRadius',
    'borderTopRightRadius',
    'borderBottomRightRadius',
    'borderBottomLeftRadius',
    'borderImage',
    'borderImageSource',
    'borderImageSlice',
    'borderImageWidth',
    'borderImageOutset',
    'borderImageRepeat',
    'borderCollapse',
    'borderSpacing',
];

/* 2. Box Model */
const boxModelPart1: string[] = [
    'display',
    'flex',
    'flexBasis',
    'flexDirection',
    'flexFlow',
    'flexGrow',
    'flexShrink',
    'flexWrap',
    'grid',
    'gridArea',
    'gridAutoRows',
    'gridAutoColumns',
    'gridAutoFlow',
    'gridGap',
    'gridRow',
    'gridRowStart',
    'gridRowEnd',
    'gridRowGap',
    'gridColumn',
    'gridColumnStart',
    'gridColumnEnd',
    'gridColumnGap',
    'gridTemplate',
    'gridTemplateAreas',
    'gridTemplateRows',
    'gridTemplateColumns',
    'gap',
    'alignContent',
    'alignItems',
    'alignSelf',
    'justifyContent',
    'justifyItems',
    'justifySelf',
    'order',
    'float',
    'clear',
    'boxSizing',
    'width',
    'minWidth',
    'maxWidth',
    'height',
    'minHeight',
    'maxHeight',
    'margin',
    'marginTop',
    'marginRight',
    'marginBottom',
    'marginLeft',
    'padding',
    'paddingVertical',
    'paddingHorizontal',
    'paddingStart',
    'paddingEnd',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft',
];
const boxModelPart2: string[] = ['objectFit', 'objectPosition', 'overflow', 'overflowX', 'overflowY'];
const boxModel = ({ border }: { border: boolean }): string[] =>
    [].concat(boxModelPart1, border ? borderProps : [], boxModelPart2);

/* 3. Typography */
const typography: string[] = [
    'color',
    'font',
    'fontWeight',
    'fontSize',
    'fontFamily',
    'fontStyle',
    'fontVariant',
    'fontSizeAdjust',
    'fontStretch',
    'fontEffect',
    'fontEmphasize',
    'fontEmphasizePosition',
    'fontEmphasizeStyle',
    'fontSmooth',
    'lineHeight',
    'direction',
    'letterSpacing',
    'whiteSpace',
    'textAlign',
    'textAlignLast',
    'textTransform',
    'textDecoration',
    'textEmphasis',
    'textEmphasisColor',
    'textEmphasisStyle',
    'textEmphasisPosition',
    'textIndent',
    'textJustify',
    'textOutline',
    'textWrap',
    'textOverflow',
    'textOverflowEllipsis',
    'textOverflowMode',
    'textOrientation',
    'textShadow',
    'verticalAlign',
    'wordWrap',
    'wordBreak',
    'wordSpacing',
    'overflowWrap',
    'tabSize',
    'hyphens',
    'unicodeBidi',
    'columns',
    'columnCount',
    'columnFill',
    'columnGap',
    'columnRule',
    'columnRuleColor',
    'columnRuleStyle',
    'columnRuleWidth',
    'columnSpan',
    'columnWidth',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakInside',
    'src',
];

/* 4. Visual */
const visualPart1: string[] = [
    'listStyle',
    'listStylePosition',
    'listStyleType',
    'listStyleImage',
    'tableLayout',
    'emptyCells',
    'captionSide',
    'background',
    'backgroundColor',
    'backgroundImage',
    'backgroundRepeat',
    'backgroundPosition',
    'backgroundPositionX',
    'backgroundPositionY',
    'backgroundSize',
    'backgroundClip',
    'backgroundOrigin',
    'backgroundAttachment',
    'backgroundBlendMode',
];
const visualPart2: string[] = [
    'outline',
    'outlineWidth',
    'outlineStyle',
    'outlineColor',
    'outlineOffset',
    'boxShadow',
    'boxDecorationBreak',
    'transform',
    'transformOrigin',
    'transformStyle',
    'backfaceVisibility',
    'perspective',
    'perspectiveOrigin',
    'visibility',
    'cursor',
    'opacity',
    'filter',
    'isolation',
    'backdropFilter',
    'mixBlendMode',
];
const visual = ({ border }: { border: boolean }): string[] =>
    [].concat(visualPart1, border ? borderProps : [], visualPart2);

/* 5. Animation */
const animation: string[] = [
    'transition',
    'transitionDelay',
    'transitionTimingFunction',
    'transitionDuration',
    'transitionProperty',
    'animation',
    'animationName',
    'animationDuration',
    'animationPlayState',
    'animationTimingFunction',
    'animationDelay',
    'animationIterationCount',
    'animationDirection',
    'animationFillMode',
];

/* 6. Miscellaneous */
const misc: string[] = [
    'appearance',
    'content',
    'clip',
    'clipPath',
    'counterReset',
    'counterIncrement',
    'resize',
    'userSelect',
    'navIndex',
    'navUp',
    'navRight',
    'navDown',
    'navLeft',
    'pointerEvents',
    'quotes',
    'touchAction',
    'willChange',
    'zoom',
    'fill',
    'fillRule',
    'clipRule',
    'stroke',
];

///

let cachedGroups: string[] = [];

function generateCache(borderInBoxModel: boolean): string[] {
    cachedGroups = [].concat(
        positioning,
        boxModel({ border: borderInBoxModel }),
        typography,
        visual({ border: !borderInBoxModel }),
        animation,
        misc,
    );
    return cachedGroups;
}

export const orderGroups = (borderInBoxModel = false): string[] =>
    cachedGroups.length > 0 ? cachedGroups : generateCache(borderInBoxModel);
